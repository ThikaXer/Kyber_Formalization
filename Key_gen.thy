theory Key_gen

imports Kyber_spec
        Compress
        "Jordan_Normal_Form.Matrix"

begin

(* This type corresponds to \<int>q = \<int>/q\<int> *) 
typ "'a mod_ring"

(* This type corresponds to \<int>q[X] *) 
typ "'a mod_ring poly"

(* This type corresponds to \<int>q[X] / (X^n + 1) *) 
typ "'a gf"


(* This type corresponds to vectors over \<int>q[X] / (X^n + 1) *) 
typ "'a gf vec"

(* This type corresponds to a matrix over \<int>q[X] / (X^n + 1) *) 
typ "'a gf mat"

context kyber_spec
begin

definition to_module :: "int \<Rightarrow> 'a gf" where
  "to_module x = to_gf [: Abs_mod_ring x :]"


text \<open>In the following the key generation, encryption and decryption algorithms 
  of Kyber are stated. Here , the variables have the meaning:
  \begin{itemize}
    \item $A$: matrix, part of Alices public key
    \item $s$: vector, Alices sectret key
    \item $t$: is the key generated by Alice from $A$ and $s$ in \<open>key_gen\<close>
    \item $r$: Bobs "secret" key, randomly picked vector
    \item $m$: message bits, $m\in \{0,1\}^{256}$
    \item $(u,v)$: encrypted message
    \item $dt$, $du$, $dv$: the compression parameters for $t$, $u$ and $v$ respectively. 
      Notice that \<open>0 < d < \<lceil>log_2 q\<rceil>\<close>. The $d$ values are public knowledge.
    \item $e$, $e1 and $e2$: error parametrs to obscure the message. 
      We need to make certain that an eavesdropper cannot distinguish 
      the encrypted message from uniformly random input.
      Notice that $e$ and $e1$ are vectors while $e2$ is a mere element in \<open>\<int>_q[X]/(X^n+1).\<close>
  

  \end{itemize}\<close>

fun key_gen :: "nat \<Rightarrow> ('a gf) mat \<Rightarrow> ('a gf) vec \<Rightarrow> 
                ('a gf) vec \<Rightarrow> ('a gf) vec" where 
"key_gen dt A s e = compress_vec dt (A *\<^sub>v s + e)"

fun encrypt :: "('a gf) vec \<Rightarrow> ('a gf) mat \<Rightarrow> ('a gf) vec \<Rightarrow> 
                ('a gf) vec \<Rightarrow> ('a gf) \<Rightarrow>
                nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow>
                'a gf \<Rightarrow> ('a gf vec) * ('a gf)" where
"encrypt t A r e1 e2 dt du dv m = 
  (compress_vec du ((transpose_mat A) *\<^sub>v r + e1),  
   compress_poly dv ((decompress_vec dt t) \<bullet> r + e2 + 
      to_module (round((real_of_int q)/2)) * m)) "


fun decrypt :: "('a gf vec) * ('a gf) \<Rightarrow> ('a gf) vec \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 'a gf" where
  "decrypt (u,v) s du dv = compress_poly 1 
      ((decompress_poly dv v) - s \<bullet> (decompress_vec du u))"


(*TODO

the matix A, the errors and Alices and Bobs private keys s and r need to be 
randomly generated by some sampling method.
\<Rightarrow> Here stochastical interpretation comes into play!

*)


(*
fun sample_matrix where "sample_matrix k rho = TODO"

fun Sample_vector where "Sample beta_eta_k sigma = TODO"

type seed = int

fun key_gen :: "seed \<Rightarrow> seed \<Rightarrow> vector" where 
"key_gen rho sigma = (compress q (A s + e) d_t) where A
= sample_matrix q k rho and (s,e) = sample_vector beta_eta_k sigma"
*)













end

end
