theory Crypto_Scheme

imports Kyber_spec
        Compress
        Abs_Gf

begin

(* This type corresponds to \<int>q = \<int>/q\<int> *) 
typ "'a mod_ring"

(* This type corresponds to \<int>q[X] *) 
typ "'a mod_ring poly"

(* This type corresponds to \<int>q[X] / (X^n + 1) *) 
typ "'a gf"


(* This type corresponds to vectors in (\<int>q[X] / (X^n + 1))^k *) 
typ "('a gf, 'k) vec"

(* This type corresponds to a \<open>k\<times>k\<close> matrix over \<int>q[X] / (X^n + 1) *) 
typ "(('a gf, 'k) vec, 'k) vec"




context kyber_spec
begin

definition to_module :: "int \<Rightarrow> 'a gf" where
  "to_module x = to_gf [: of_int_mod_ring x :]"


text \<open>In the following the key generation, encryption and decryption algorithms 
  of Kyber are stated. Here , the variables have the meaning:
  \begin{itemize}
    \item $A$: matrix, part of Alices public key
    \item $s$: vector, Alices sectret key
    \item $t$: is the key generated by Alice from $A$ and $s$ in \<open>key_gen\<close>
    \item $r$: Bobs "secret" key, randomly picked vector
    \item $m$: message bits, $m\in \{0,1\}^{256}$
    \item $(u,v)$: encrypted message
    \item $dt$, $du$, $dv$: the compression parameters for $t$, $u$ and $v$ respectively. 
      Notice that \<open>0 < d < \<lceil>log_2 q\<rceil>\<close>. The $d$ values are public knowledge.
    \item $e$, $e1 and $e2$: error parametrs to obscure the message. 
      We need to make certain that an eavesdropper cannot distinguish 
      the encrypted message from uniformly random input.
      Notice that $e$ and $e1$ are vectors while $e2$ is a mere element in \<open>\<int>_q[X]/(X^n+1).\<close>
  

  \end{itemize}\<close>



definition key_gen :: "nat \<Rightarrow> (('a gf, 'k) vec, 'k) vec \<Rightarrow> ('a gf, 'k) vec \<Rightarrow> 
                ('a gf, 'k) vec \<Rightarrow> ('a gf, 'k) vec" where 
"key_gen dt A s e = compress_vec dt (A *v s + e)"

definition encrypt :: "('a gf, 'k) vec \<Rightarrow> (('a gf, 'k) vec, 'k) vec \<Rightarrow> ('a gf, 'k) vec \<Rightarrow> 
                ('a gf, 'k) vec \<Rightarrow> ('a gf) \<Rightarrow>
                nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow>
                'a gf \<Rightarrow> (('a gf, 'k) vec) * ('a gf)" where
"encrypt t A r e1 e2 dt du dv m = 
  (compress_vec du ((transpose A) *v r + e1),  
   compress_poly dv (scalar_product (decompress_vec dt t) r + e2 + 
      to_module (round((real_of_int q)/2)) * m)) "


definition decrypt :: "('a gf, 'k) vec \<Rightarrow> ('a gf) \<Rightarrow> ('a gf, 'k) vec \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 'a gf" where
  "decrypt u v s du dv = compress_poly 1 
      ((decompress_poly dv v) - scalar_product s (decompress_vec du u))"


(*TODO

the matix A, the errors and Alices and Bobs private keys s and r need to be 
randomly generated by some sampling method.
\<Rightarrow> Here stochastical interpretation comes into play!

*)

fun f_int_to_poly :: "(int \<Rightarrow> int) \<Rightarrow> ('a gf) \<Rightarrow> ('a gf)" where
  "f_int_to_poly f = 
        to_gf \<circ>
        Poly \<circ>
        (map of_int_mod_ring) \<circ>
        (map f) \<circ>
        (map to_int_mod_ring) \<circ>
        coeffs \<circ>
        of_gf"

(*
definition mod_plus_minus_poly :: "('a gf) \<Rightarrow> ('a gf)" where
  "mod_plus_minus_poly p = f_int_to_poly (\<lambda>x. x mod+- q) p"

definition mod_plus_minus_vec :: "('a gf, 'k) vec \<Rightarrow> ('a gf, 'k) vec" where
  "mod_plus_minus_vec p = map_vector mod_plus_minus_poly p"
*) 

definition compress_error_poly :: "nat \<Rightarrow> 'a gf \<Rightarrow> 'a gf" where
  "compress_error_poly d y = decompress_poly d (compress_poly d y) - y"

definition compress_error_vec :: "nat \<Rightarrow> ('a gf, 'k) vec \<Rightarrow> ('a gf, 'k) vec" where
  "compress_error_vec d y = decompress_vec d (compress_vec d y) - y"

text \<open>Get the i-th entry of vector and j-th coefficient of polynomial\<close>

definition vec_coeff :: "('a gf) \<Rightarrow> ('a mod_ring)" where 
  "vec_coeff v = TO_DO"


lemma scalar_product_linear_left:
  "scalar_product (a+b) c = scalar_product a c + scalar_product b (c :: ('a gf, 'k) vec)"
unfolding scalar_product_def
by auto (metis (no_types, lifting) distrib_right sum.cong sum.distrib)

lemma scalar_product_linear_right:
  "scalar_product a (b+c) = scalar_product a b + scalar_product a (c :: ('a gf, 'k) vec)"
unfolding scalar_product_def
by auto (metis (no_types, lifting) distrib_left sum.cong sum.distrib)

lemma scalar_product_assoc:
  "scalar_product (A *v s) (r :: ('a gf, 'k) vec ) = scalar_product s (r v* A)"
unfolding scalar_product_def matrix_vector_mult_def vector_matrix_mult_def
proof auto
  have "(\<Sum>i\<in>UNIV. (\<Sum>j\<in>UNIV. (vec_nth (vec_nth A i) j) * (vec_nth s j)) * (vec_nth r i)) = 
        (\<Sum>i\<in>UNIV. (\<Sum>j\<in>UNIV. (vec_nth (vec_nth A i) j) * (vec_nth s j) * (vec_nth r i)))"
    by (simp add: sum_distrib_right)
  also have "\<dots> = (\<Sum>j\<in>UNIV. (\<Sum>i\<in>UNIV. (vec_nth (vec_nth A i) j) * (vec_nth s j) * (vec_nth r i)))"
    using sum.swap .
  also have "\<dots> = (\<Sum>j\<in>UNIV. (\<Sum>i\<in>UNIV. (vec_nth s j) * (vec_nth (vec_nth A i) j) * (vec_nth r i)))"
    by (metis (no_types, lifting) mult_commute_abs sum.cong)
  also have "\<dots> = (\<Sum>j\<in>UNIV. (vec_nth s j) * (\<Sum>i\<in>UNIV. (vec_nth (vec_nth A i) j) * (vec_nth r i)))"
    by (metis (no_types, lifting) mult.assoc sum.cong sum_distrib_left)
  finally show "(\<Sum>i\<in>UNIV. (\<Sum>j\<in>UNIV. (vec_nth (vec_nth A i) j) * (vec_nth s j)) * (vec_nth r i)) =
    (\<Sum>j\<in>UNIV. (vec_nth s j) * (\<Sum>i\<in>UNIV. (vec_nth (vec_nth A i) j) * (vec_nth r i)))" by blast
qed

text \<open>Lemma about coeff Poly\<close>

lemma set_coeff_Poly: "set ((coeffs \<circ> Poly) xs) \<subseteq> set xs" 
by auto (metis append.assoc append_Cons in_set_conv_decomp split_strip_while_append) 

text \<open>We now want to show the deterministic correctness of the algorithm. 
  That means, after choosing the variables correctly, generating the public key, encrypting 
  and decrypting, we get back the original message.\<close>



lemma kyber_correct:
  fixes A s r e e1 e2 dt du dv ct cu cv t u v
  assumes "t = key_gen dt A s e"
          "(u,v) = encrypt t A r e1 e2 dt du dv m"
          "ct = compress_error_vec dt (A *v s + e)"
          "cu = compress_error_vec du ((transpose A) *v r + e1)"
          "cv = compress_error_poly dv (scalar_product (decompress_vec dt t) r + e2 + 
            to_module (round((real_of_int q)/2)) * m)"
          "abs_infty_poly (scalar_product e r + e2 + cv - scalar_product s e1 + 
            scalar_product ct r - scalar_product s cu) < round (of_int q / 4)"
          "set ((map to_int_mod_ring \<circ> coeffs \<circ> of_gf) m) \<subseteq> {0,1}"
          "degree (of_gf m) < n"
  shows "decrypt u v s du dv = m"
proof -
  have t_correct: "decompress_vec dt t = A *v s + e + ct " 
    using assms(1) assms(3) unfolding compress_error_vec_def key_gen_def by simp
  have u_correct: "decompress_vec du u = (transpose A) *v r + e1 + cu" 
    using assms(2) assms(4) unfolding encrypt_def compress_error_vec_def by simp
  have v_correct: "decompress_poly dv v = scalar_product (decompress_vec dt t) r + e2 + 
            to_module (round((real_of_int q)/2)) * m + cv"
    using assms(2) assms(5) unfolding encrypt_def compress_error_poly_def by simp
  have v_correct': "decompress_poly dv v = scalar_product (A *v s + e) r + e2 + 
            to_module (round((real_of_int q)/2)) * m + cv + scalar_product ct r"
   using t_correct v_correct by (auto simp add: scalar_product_linear_left)
  let ?t = "decompress_vec dt t"
  let ?u = "decompress_vec du u"
  let ?v = "decompress_poly dv v"
  define w where "w = scalar_product e r + e2 + cv - scalar_product s e1 + 
            scalar_product ct r - scalar_product s cu"
  have w_length: "abs_infty_poly w < round (of_int q / 4)" unfolding w_def using assms(6) sorry
  have vsu: "?v - scalar_product s ?u = 
        w + to_module (round((real_of_int q)/2)) * m" 
    unfolding w_def by (auto simp add: u_correct v_correct' scalar_product_linear_left 
                       scalar_product_linear_right scalar_product_assoc)
  define m' where "m' = decrypt u v s du dv"
  have decompress_01: "decompress 1 a = round(real_of_int q / 2) * a" if "a\<in>{0,1}" for a
    unfolding decompress_def using that by auto 
  have "decompress_poly 1  m' = to_module (round((real_of_int q)/2)) * m'"
  proof -
    have "poly.coeff (of_gf m') i \<in> {0,1}" for i unfolding m'_def decrypt_def  sorry
    have "poly.coeff (of_gf (decompress_poly 1 m')) i = 
          poly.coeff (of_gf (to_module (round((real_of_int q)/2)) * m')) i"
    for i 
    unfolding decompress_poly_def using of_gf_to_gf'[of "Poly
           (map (of_int_mod_ring \<circ> (decompress (Suc 0) \<circ> to_int_mod_ring))
             (coeffs (of_gf m')))"] apply (auto simp add: of_gf_to_gf') sorry
    then have eq: "of_gf (decompress_poly 1 m') = of_gf (to_module (round((real_of_int q)/2)) * m')"
      by (simp add: poly_eq_iff)
    show ?thesis using arg_cong[OF eq, of "to_gf"] to_gf_of_gf[of "decompress_poly 1 m'"] 
      to_gf_of_gf[of "to_module (round (real_of_int q / 2)) * m'"] by auto
  qed




        sorry
    then have "decompress 1 m' = round(real_of_int q / 2) * m'" (*case distinction m' = 0,1*)





    have coeff_01: "((map to_int_mod_ring \<circ> coeffs \<circ> of_gf) m) ! i \<in> {0,1}" 
      if "i\<in>{0..degree (of_gf m)}"for i 
    proof (cases "m=0")
    case True
      then have "of_gf m = 0" by auto
      then have "coeffs (of_gf m) " sorry
      then show ?thesis sorry
    next
    case False
    then show ?thesis sorry
    qed
      
      using assms(7) coeff_in_coeffs sorry
    
    
    have "decompress 1 (((map to_int_mod_ring \<circ> coeffs \<circ> of_gf) m') ! i) = 
      round(real_of_int q / 2) * (((map to_int_mod_ring \<circ> coeffs \<circ> of_gf) m') ! i)" 
      if "i\<in>{0..degree (of_gf m)}"for i 
    using decompress_01[OF coeff_01[OF that]] sorry 
  qed
      sorry
  have "abs_infty_poly (?v - scalar_product s ?u - to_module (round((real_of_int q)/2)) * m') \<le> 
        round (of_int q / 4)"
    using vsu assms(6) decompress_compress apply simp sorry
  then have "abs_infty_poly (?w + to_module (round((real_of_int q)/2)) * m - 
              to_module (round((real_of_int q)/2)) * m') \<le> round (of_int q / 4)" sorry
  then have "abs_infty_poly (to_module (round((real_of_int q)/2)) * (m - m')) < 
              2 * round (of_int q / 4)" using abs_infty_poly_triangle_ineq sorry
  then show ?thesis sorry
qed

find_theorems "set (coeffs _)"

lemma kyber_one_minus_delta_correct:
  assumes "delta = P ()"








(*
fun sample_matrix where "sample_matrix k rho = TODO"

fun Sample_vector where "Sample beta_eta_k sigma = TODO"

type seed = int

fun key_gen :: "seed \<Rightarrow> seed \<Rightarrow> vector" where 
"key_gen rho sigma = (compress q (A s + e) d_t) where A
= sample_matrix q k rho and (s,e) = sample_vector beta_eta_k sigma"
*)













end

end
