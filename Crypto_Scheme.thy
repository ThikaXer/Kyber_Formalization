theory Crypto_Scheme

imports Kyber_spec
        Compress
        Abs_Gf
        "Jordan_Normal_Form.Matrix"

begin

(* This type corresponds to \<int>q = \<int>/q\<int> *) 
typ "'a mod_ring"

(* This type corresponds to \<int>q[X] *) 
typ "'a mod_ring poly"

(* This type corresponds to \<int>q[X] / (X^n + 1) *) 
typ "'a gf"


(* This type corresponds to vectors over \<int>q[X] / (X^n + 1) *) 
typ "'a gf vec"

(* This type corresponds to a matrix over \<int>q[X] / (X^n + 1) *) 
typ "'a gf mat"




context kyber_spec
begin

definition to_module :: "int \<Rightarrow> 'a gf" where
  "to_module x = to_gf [: of_int_mod_ring x :]"


text \<open>In the following the key generation, encryption and decryption algorithms 
  of Kyber are stated. Here , the variables have the meaning:
  \begin{itemize}
    \item $A$: matrix, part of Alices public key
    \item $s$: vector, Alices sectret key
    \item $t$: is the key generated by Alice from $A$ and $s$ in \<open>key_gen\<close>
    \item $r$: Bobs "secret" key, randomly picked vector
    \item $m$: message bits, $m\in \{0,1\}^{256}$
    \item $(u,v)$: encrypted message
    \item $dt$, $du$, $dv$: the compression parameters for $t$, $u$ and $v$ respectively. 
      Notice that \<open>0 < d < \<lceil>log_2 q\<rceil>\<close>. The $d$ values are public knowledge.
    \item $e$, $e1 and $e2$: error parametrs to obscure the message. 
      We need to make certain that an eavesdropper cannot distinguish 
      the encrypted message from uniformly random input.
      Notice that $e$ and $e1$ are vectors while $e2$ is a mere element in \<open>\<int>_q[X]/(X^n+1).\<close>
  

  \end{itemize}\<close>

definition key_gen :: "nat \<Rightarrow> ('a gf) mat \<Rightarrow> ('a gf) vec \<Rightarrow> 
                ('a gf) vec \<Rightarrow> ('a gf) vec" where 
"key_gen dt A s e = compress_vec dt (A *\<^sub>v s + e)"

definition encrypt :: "('a gf) vec \<Rightarrow> ('a gf) mat \<Rightarrow> ('a gf) vec \<Rightarrow> 
                ('a gf) vec \<Rightarrow> ('a gf) \<Rightarrow>
                nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow>
                'a gf \<Rightarrow> ('a gf vec) * ('a gf)" where
"encrypt t A r e1 e2 dt du dv m = 
  (compress_vec du ((transpose_mat A) *\<^sub>v r + e1),  
   compress_poly dv ((decompress_vec dt t) \<bullet> r + e2 + 
      to_module (round((real_of_int q)/2)) * m)) "


definition decrypt :: "('a gf) vec \<Rightarrow> ('a gf) \<Rightarrow> ('a gf) vec \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 'a gf" where
  "decrypt u v s du dv = compress_poly 1 
      ((decompress_poly dv v) - s \<bullet> (decompress_vec du u))"


(*TODO

the matix A, the errors and Alices and Bobs private keys s and r need to be 
randomly generated by some sampling method.
\<Rightarrow> Here stochastical interpretation comes into play!

*)

fun f_int_to_poly :: "(int \<Rightarrow> int) \<Rightarrow> ('a gf) \<Rightarrow> ('a gf)" where
  "f_int_to_poly f = 
        to_gf \<circ>
        Poly \<circ>
        (map of_int_mod_ring) \<circ>
        (map f) \<circ>
        (map to_int_mod_ring) \<circ>
        coeffs \<circ>
        of_gf"

fun mod_plus_minus_poly :: "('a gf) \<Rightarrow> ('a gf)" where
  "mod_plus_minus_poly p = f_int_to_poly (\<lambda>x. x mod+- q) p"

fun mod_plus_minus_vec :: "('a gf) vec \<Rightarrow> ('a gf) vec" where
  "mod_plus_minus_vec p = map_vec mod_plus_minus_poly p"

fun compress_error_poly :: "nat \<Rightarrow> ('a gf) \<Rightarrow> ('a gf)" where
  "compress_error_poly d y = mod_plus_minus_poly (y - decompress_poly d (compress_poly d y))"

fun compress_error_vec :: "nat \<Rightarrow> ('a gf) vec \<Rightarrow> ('a gf) vec" where
  "compress_error_vec d y = mod_plus_minus_vec (y - decompress_vec d (compress_vec d y))"








(*TODO: show that abs_infty_poly is indeed a norm on 'a gf and show triangle inequality!*)





lemma kyber_correct:
  fixes A s r e e1 e2 dt du dv ct cu cv t u v
  assumes "t = key_gen dt A s e"
          "(u,v) = encrypt t A r e1 e2 dt du dv m"
          "ct = compress_error_vec dt (A *\<^sub>v s + e)"
          "cu = compress_error_vec du ((transpose_mat A) *\<^sub>v r + e1)"
          "cv = compress_error_poly dv ((decompress_vec dt t) \<bullet> r + e2 + 
            to_module (round((real_of_int q)/2)) * m)"
          "abs_infty_poly (e \<bullet> r + e2 + cv - s \<bullet> e1 + ct \<bullet> r - s \<bullet> cu) < round (of_int q / 4)"
  shows "decrypt u v s du dv = m"
proof -
  have "t = A *\<^sub>v s + e + ct " using assms unfolding key_gen_def sorry
  have "u = (transpose_mat A) *\<^sub>v r + e1 + cu" using assms unfolding encrypt_def sorry
  have "v = (decompress_vec dt t) \<bullet> r + e2 + to_module (round((real_of_int q)/2)) * m + cv"
    using assms unfolding encrypt_def sorry
  have "v -  s \<bullet> u = e \<bullet> r + e2 + to_module (round((real_of_int q)/2)) * m 
          + cv - s \<bullet> e1 + ct \<bullet> r - s \<bullet> cu" sorry
  let ?w = "e \<bullet> r + e2 + cv - s \<bullet> e1 + ct \<bullet> r - s \<bullet> cu"
  let ?m' = "decrypt u v s du dv"
  have "abs_infty_poly (v -  s \<bullet> u - to_module (round((real_of_int q)/2)) * ?m') \<le> 
        round (of_int q / 4)" sorry
  then have "abs_infty_poly (?w + to_module (round((real_of_int q)/2)) * m - 
              to_module (round((real_of_int q)/2)) * ?m') \<le> round (of_int q / 4)" sorry
  then have "abs_infty_poly (to_module (round((real_of_int q)/2)) * (m - ?m')) < 
              2 * round (of_int q / 4)" using abs_infty_poly_triangle_ineq sorry
  then show ?thesis sorry
qed

find_theorems name: triang

lemma kyber_one_minus_delta_correct:
  assumes "delta = P ()"








(*
fun sample_matrix where "sample_matrix k rho = TODO"

fun Sample_vector where "Sample beta_eta_k sigma = TODO"

type seed = int

fun key_gen :: "seed \<Rightarrow> seed \<Rightarrow> vector" where 
"key_gen rho sigma = (compress q (A s + e) d_t) where A
= sample_matrix q k rho and (s,e) = sample_vector beta_eta_k sigma"
*)













end

end
